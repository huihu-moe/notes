# final 关键字

## 所有的 final 修饰的字段都是编译期常量吗？

不是。并不是所有的 final 修饰的字段都是编译期常量，final 修饰的字段只是初始化后无法修改。

## 如何理解 private 所修饰的方法是隐式的 final？

final 修饰的方法无法被子类重写。而 private 修饰的方法同样无法被子类重写，因此 private 方法是隐式的 final。

## 说说 final 类型的类如何拓展?

使用组合关系实现 final 类的拓展。拓展 final 类，保存 final 类实例的引用。

## final 方法可以被重载吗？

可以。

## 父类的 final 方法能不能够被子类重写？

父类的 final 方法可以被子类重载，但不能被重写。

## 说说 final 域重排序规则？

### final 域为基本类型时的重排序

#### 写重排序规则

写 final 域的重排序规则禁止对 final 域的写重排序到构造函数之外，这个规则的实现主要包含了两个方面：

- JMM 禁止编译器把 final 域的写重排序到构造函数之外；
- 编译器会在 final 域写之后，构造函数 return 之前，插入一个 storestore 屏障。这个屏障可以禁止处理器把 final 域的写重排序到构造函数之外。

#### 读重排序规则

读 final 域重排序规则为：在一个线程中，初次读对象引用和初次读该对象包含的 final 域，JMM 会禁止这两个操作的重排序。(注意，这个规则仅仅是针对处理器)，处理器会在读 final 域操作的前面插入一个 LoadLoad 屏障。实际上，读对象的引用和读该对象的 final 域存在间接依赖性，一般处理器不会重排序这两个操作。但是有一些处理器会重排序，因此，这条禁止重排序规则就是针对这些处理器而设定的。

读 final 域的重排序规则可以确保：在读一个对象的 final 域之前，一定会先读这个包含这个 final 域的对象的引用。

### final 域为引用数据类型

#### 写重排序

针对引用数据类型，final域写针对编译器和处理器重排序增加了这样的约束：在构造函数内对一个final修饰的对象的成员域的写入，与随后在构造函数之外把这个被构造的对象的引用赋给一个引用变量，这两个操作是不能被重排序的。注意这里的是“增加”也就说前面对final基本数据类型的重排序规则在这里还是使用。

按照final修饰的数据类型分类：

- 基本数据类型:

  - final 域写：禁止 final 域写与构造方法重排序，即禁止 final 域写重排序到构造方法之外，从而保证该对象对所有线程可见时，该对象的 final 域全部已经初始化过。
  - final 域读：禁止初次读对象的引用与读该对象包含的 final 域的重排序。

- 引用数据类型：

  - 额外增加约束：禁止在构造函数对一个 final 修饰的对象的成员域的写入与随后将这个被构造的对象的引用赋值给引用变量重排序

## 说说 final 的原理？

写 final 域会要求编译器在 final 域写之后，构造函数返回前插入一个 StoreStore 屏障。读 final 域的重排序规则会要求编译器在读 final 域的操作前插入一个 LoadLoad 屏障。

但是，对 final 域的读或写是否插入内存屏障还需要考虑具体的处理器。以 X86 处理器为例，X86 不会对写-写重排序，所以 StoreStore 屏障可以省略。由于不会对有间接依赖性的操作重排序，所以在 X86 处理器中，读 final 域需要的 LoadLoad 屏障也会被省略掉。

## 使用 final 的限制条件和局限性？

- 当声明一个 final 成员时，必须在构造函数退出前设置它的值。
- 将指向对象的成员声明为 final 只能将该引用设为不可变的，而非所指的对象。
- 如果一个对象将会在多个线程中访问并且你并没有将其成员声明为 final，则必须提供其他方式保证线程安全。其他方式可以包括声明成员为 volatile，使用 synchronized 或者显式 Lock 控制所有该成员的访问。
