# Java 并发

## 多线程的出现是要解决什么问题的？

合理利用 CPU 的高性能，平衡这三者的速度差异，计算机体系结构、操作系统、编译程序都做出了贡献，主要体现为:

- CPU 增加了缓存，以均衡与内存的速度差异；导致**可见性**问题
- 操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I/O 设备的速度差异；导致**原子性**问题
- 编译程序优化指令执行次序，使得缓存能够得到更加合理地利用。导致**有序性**问题

## 并发出现线程不安全的本质是什么？

可见性问题，原子性问题和有序性问题。

- 可见性问题：CPU 缓存引起
- 原子性问题：分时复用引起
- 有序性问题：重排序引起，源代码-》编译器优化重排序-》指令级并行重排序-》内存系统重排序-》最终执行的指令序列

## Java 是怎么解决并发问题的？

并发问题的本质是可见性、原子性和有序性出现问题，JMM（Java 内存模型）提供了 3 个关键字（volatile、 synchronized 和 final）和 8 个 Happens-Before 规则。

1. 原子性

   Java 内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过 synchronized 和 Lock 来实现。由于 synchronized 和 Lock 能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。

2. 可见性

   Java 提供了 volatile 关键字来保证可见性。当一个共享变量被 volatile 修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。

3. 有序性

   JMM 是通过 Happens-Before 规则来保证有序性的。
   1. 单一线程原则，在一个线程内，在程序前面的操作先行发生于后面的操作。
   2. 管程锁定规则，一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。
   3. volatile 变量规则，对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。
   4. 线程启动规则，Thread 对象的 start() 方法调用先行发生于此线程的每一个动作。
   5. 线程加入规则，Thread 对象的结束先行发生于 join() 方法返回。
   6. 线程中断规则，对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 interrupted() 方法检测到是否有中断发生。
   7. 对象终结规则，一个对象的初始化完成(构造函数执行结束)先行发生于它的 finalize() 方法的开始。
   8. 传递性规则，如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C。

## 线程安全？

一个类在可以被多个线程安全调用时就是线程安全的。

线程安全不是一个非真即假的命题，可以将共享数据按照安全程度的强弱顺序分成以下五类: 不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。

## 线程安全的实现方法？

1. 互斥同步
   synchronized 和 ReentrantLock。
2. 非阻塞同步
   1. CAS
   2. JUS 原子类
3. 线程不访问共享变量
