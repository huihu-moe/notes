# CAS

CAS的全称为compare and swap，比较并交换，是一个原子性的操作，对应到CPU指令为cmpxchg。

CAS 有三个操作数：当前值A、内存值V、要修改的新值B，假设当前值A跟内存值V相等，那就将内存值V改成B，假设当前值A跟内存值V不相等，要么就重试，要么就放弃更新，将当前值与内存值进行对比，判断是否有被修改过，这就是CAS的核心。

CAS相比synchronized锁的优点是，多个线程都可以直接操作共享资源，在实际去修改的时候才去判断能否修改成功，更加高效。

CAS的缺点是ABA问题，ABA问题是指读取A的预期值和当前内存值的时间间隔中，共享资源虽然被多次修改但是最终A的预期值和内存值相同，CAS操作误认为该共享资源没有发生变化。

解决方案是引入版本号的概念，保证预期值，内存值，版本号对应。

Java1.5提供了AtomicStampedReference类用于解决CAS的ABA问题，该类的CAS方法先检查当前引用是否等于预期引用（即当前值是否等于预期值），然后才检查当前标志是否等于预期标志（版本号是否一致）。

## AtomicLong和LongAdder比较

AtomicLong使用CAS,做累加的时候实际上就是多个线程操作同一个目标资源，在高并发时，只有一个线程是执行成功的，其他的线程都会失败，不断自旋（重试），自旋会成为瓶颈。

LongAdder的思想就是把要操作的目标资源「分散」到数组Cell，每个线程对自己的 Cell 变量的 value 进行原子操作，大大降低了失败的次数。
