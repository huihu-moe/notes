# HTTP

HTTP「协议」是客户端和服务器「交互」的一种通迅的格式。

HTTP版本：
- HTTP1.0默认是短连接，每次与服务器交互，都需要新开一个连接
- HTTP1.1版本最主要的是「默认持久连接」。只要客户端服务端没有断开TCP连接，就一直保持连接，可以发送多次HTTP请求。其次就是「断点续传」（Chunked transfer-coding）。利用HTTP消息头使用分块传输编码，将实体主体分块进行传输
- HTTP/2不再以文本的方式传输，采用「二进制分帧层」，对头部进行了「压缩」，支持「流控」，最主要就是HTTP/2是支持「多路复用」的（通过单一的TCP连接「并行」发起多个的请求和响应消息）
- HTTP/3底层是UDP。使用HTTP/3能够减少RTT「往返时延」（TCP三次握手，TLS握手）

HTTP1.1提出的「管线化」只能「串行」（一个响应必须完全返回后，下一个请求才会开始传输）。

HTTP/2多路复用则是利用「分帧」数据流，把HTTP协议分解为「互不依赖」的帧（为每个帧「标序」发送，接收回来的时候按序重组），进而可以「乱序」发送避免「一定程度上」的队首阻塞问题。

但是，无论是HTTP1.1还是HTTP/2，response响应的「处理顺序」总是需要跟request请求顺序保持一致的。假如某个请求的response响应慢了，还是同样会有阻塞的问题。

## HTTPS过程

通过使用数字证书来对通信方进行认证。

数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。

服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名（CA的私钥签名，客户端使用CA的公钥验证签名），然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。

进行 HTTPS 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了。

加密：
- 对称密钥加密
- 非对称密钥加密
- 混合加密（使用非对称密钥加密方式传递对称密钥至通信方,使用对称密钥进行通信）

## 输入URL到页面加载过程详解

参见[知识点串联：输入URL 到页面加载过程详解](https://pdai.tech/md/develop/protocol/dev-protocol-url.html)

### 地址栏输入URL

URL : Uniform / Universal Resource Locator ， 即统一资源定位符。它实际上就是网站网址。浏览器就是靠URL来查找资源位置。

可以把URL分割成几个部分：协议、网络地址、资源路径。

- 传送协议： URL包含协议部分，是浏览器和www万维网之间的沟通方式，它会告诉浏览器正确在网路上找到资源位置。最常见的网络传输协议的是HTTP协议（超文本传输协议）（ https则是进行加密的网络传输）；其他也还有ftp 、file、 https、mailto 、git 等。还有自定义的协议（私有协议），例如tencent。不同协议有不同的通讯内容格式。
- 网络地址： 指示该连接网络上哪一台计算机，可以是域名或者IP地址，可以包括端口号；
- 资源路径： 指示从服务器上获取哪一项资源。

### DNS域名解析IP

#### 查找域名对应的IP地址

通过域名查找IP过程：浏览器缓存 -> 系统缓存 -> 本地DNS服务器缓存

浏览器搜索自己的DNS缓存（维护一张域名与IP地址对应表）
- 搜索操作系统中的DNS缓存（维护一张域名与IP地址对应表）
- 搜索操作系统的hosts文件（windows环境下，维护一张域名与IP地址对应表）
- 操作系统将域名发送到本地区域服务器（LNDS），进行查找，成功则返回结果（递归查询），失败则发起一个迭代DNS请求（迭代查询）
- 本地域名服务器LDNS将得到的IP地址返回给操作系统，同时也将IP地址缓存起来
- 操作系统将IP地址返回给浏览器，同时将IP地址缓存起来

#### DNS迭代查询和递归查询

- 递归查询：客户端与服务器之间属于递归查询，即当客户机想DNS服务器发出请求后，若DNS服务器本身不能解析，会向另一个DNS服务器发出查询请求，最后将结果转交给客户端的过程。服务器必须回答目标IP与域名的映射关系。
- 迭代查询：DNS服务器之间属于迭代查询。服务器接收到一次迭代查询回复一次结果，这个结果不一定死目标IP与域名的映射关系，也可以是其他DNS服务器的地址。

### 请求和响应数据

- TCP连接建立
- 发送http 请求
- 服务端处理
- 返回http 结果
- TCP连接关闭。

#### 建立TCP连接（3次握手）

#### 发送HTTP请求

#### 服务器处理请求

#### 返回HTTP响应结果

#### 关闭TCP连接（4次挥手）

### 浏览器加载，解析和渲染

#### 浏览器加载

加载过程如下：

- 当浏览器获得一个html文件时，会”自上而下“加载，并在加载过程中进行解析渲染。
- 加载过程中遇到外部css文件，浏览器另外发出一个请求，来获取css文件。
- 遇到图片资源，浏览器也会另外发出一个请求，来获取图片资源。这是异步请求，并不会影响html文档进行加载。
- 但是当文档加载过程中遇到js文件，html文档会挂起渲染（加载解析渲染同步）的线程，不仅要等待文档中js文件加载完毕，还要等待解析执行完毕，才可以恢复html文档的渲染线程。

加载外联js和css的阻塞情况：一个不太严谨但方便记忆的口诀：JS 全阻塞，CSS 半阻塞

- JS 会阻塞后续 DOM 解析以及其它资源(如 CSS，JS 或图片资源)的加载。
- CSS不阻塞DOM的加载和解析（它只阻塞DOM的渲染呈现。这里谈加载），不会阻塞其它资源(如图片)的加载，但是会阻塞 后续JS 文件的执行（原因之一是，js执行代码可能会依赖到css样式。css只阻塞执行而不阻塞js的加载）。
- 鉴于上面的特性，当css后面存在js的时候，css会间接地阻塞js后面资源的加载（css阻塞js，js阻塞其他资源 ）。
- 现代浏览器会进行 prefetch 优化，浏览器在获得 html 文档之后会对页面上引用的资源进行提前下载

#### 浏览器解析和渲染

步骤如下：

- 解析html，生成dom树
- 解析css，生成cssom树
- 将dom树和cssom树合并，生成渲染树
- 遍历渲染树，开始布局和计算
- 绘制渲染树，显示到屏幕

##### 解析html，生成dom树

当浏览器接收到服务器响应来的HTML文档后，会自上而下扫描文档，开始解析，遍历文档节点，生成DOM树。

整个构建过程其实包括： 字节 -> 字符 -> 令牌 -> 节点对象 -> 对象模型

##### 解析css，生成cssom树

- 每个css文件都被分析成一个stylesheet对象，每个对象都包含CSS规则。
- css规则对象包含对应于css语法的选择器和声明对象以及其他对象。

##### 将dom树和cssom树合并，生成渲染树

- 浏览器会先从dom树的根节点开始遍历每个可见节点，找到其适配的CSS样式规则并应用。
- 将dom树与cssom树结合在一起，这就是渲染树。
- 每一个渲染对象都对应着dom节点，但是非视觉（隐藏，不占位）dom元素不会插入渲染树，如<head>元素或声明display: none;的元素。
- 渲染对象与dom节点不是简单的一对一的关系，一个dom可以对应一个渲染对象，但一个dom元素也可能对应多个渲染对象，因为有很多元素不止包含一个css盒子。（如当文本被折行时，会产生多个行盒，这些行会生成多个渲染对象；又如行内元素同时包含块元素和行内元素，则会创建一个匿名块级盒包含内部行内元素，此时一个dom对应多个渲染对象）

##### 遍历渲染树，开始布局和计算

布局阶段会从渲染树的根节点开始遍历，然后确定每个节点对象在页面上的确切大小与位置。 布局阶段的输出是一个盒子模型，它会精确地捕获每个元素在屏幕内的确切位置与大小，所有相对的测量值也都会被转换为屏幕内的绝对像素值。

##### 绘制渲染树，显示到屏幕

在绘制阶段，浏览器会立即发出Paint Setup与Paint事件，开始将渲染树绘制成像素，绘制所需的时间跟CSS样式的复杂度成正比，绘制完成后，用户就可以看到页面的最终呈现效果了。