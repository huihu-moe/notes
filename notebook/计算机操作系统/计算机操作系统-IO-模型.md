# I/O 模型

部分内容摘抄自 <https://www.cyc2018.xyz/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/Socket/Socket.html>

I/O 操作一般分为两个阶段：

- 等待数据
- 将数据从内核缓冲区写入应用进程缓冲区

## 阻塞式 I/O

应用进程执行系统调用后，在阶段一（等待数据）和阶段二（数据从内核缓冲区复制到应用进程缓冲区）阻塞，直到阶段二完成。在阻塞时可让出 CPU，提高 CPU 的利用率。

![阻塞式 I/O](/assets/image/block-io.png)

## 非阻塞 I/O

应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知 I/O 是否完成，这种方式称为轮询（polling）。处理系统调用会占用 CPU，导致 CPU 利用率下降。

![非阻塞 I/O](/assets/image/nblock-io.png)

## I/O 复用

使用 select 或者 poll 等待数据，并且可以等待多个套接字中的任何一个变为可读。这一过程会被阻塞，当某一个套接字可读时返回，之后再使用 recvfrom 把数据从内核复制到进程中。

它可以让单个进程具有处理多个 I/O 事件的能力。又被称为 Event Driven I/O，即事件驱动 I/O。

![I/O 复用](/assets/image/reuse-io.png)

## 信号驱动　I/O

应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中。

相比与非阻塞　I/O 的轮询方式，信号驱动　I/O 系统调用次数较少，CPU 利用率更高。

![信号驱动 I/O](/assets/image/sig-io.png)

## 异步 I/O

应用进程执行 aio_read 系统调用会立即返回，应用进程可以继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。

异步 I/O 与信号驱动 I/O 的区别在于，异步 I/O 的信号是通知应用进程 I/O 完成，而信号驱动 I/O 的信号是通知应用进程可以开始 I/O。

![异步 I/O](/assets/image/aio.png)

- 同步 I/O：将数据从内核缓冲区复制到应用进程缓冲区的阶段（第二阶段），应用进程会阻塞。
- 异步 I/O：第二阶段应用进程不会阻塞。
- 同步 I/O 包括阻塞式 I/O、非阻塞式 I/O、I/O 复用和信号驱动 I/O ，它们的主要区别在第一个阶段。非阻塞式 I/O 、信号驱动 I/O 和异步 I/O 在第一阶段不会阻塞。

![Unix I/O 模型](/assets/image/unix-io.png)